import os
import base64
from typing import Optional
from functools import lru_cache

try:
    from cryptography.fernet import Fernet, InvalidToken
except Exception as e:  # pragma: no cover - cryptography must be installed by requirements
    Fernet = None  # type: ignore
    InvalidToken = Exception  # type: ignore


def _ensure_dir(path: str) -> None:
    directory = os.path.dirname(path)
    if directory and not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)


def _load_or_create_key() -> bytes:
    # Priority 1: explicit env var (must be urlsafe base64 32-byte key)
    env_key = os.getenv("PROXY_PASSWORD_KEY")
    if env_key:
        try:
            key_bytes = env_key.encode("utf-8")
            # Validate by attempting to construct Fernet
            Fernet(key_bytes)  # type: ignore[arg-type]
            return key_bytes
        except Exception:
            raise RuntimeError("Invalid PROXY_PASSWORD_KEY provided. It must be a urlsafe base64-encoded 32-byte key generated by Fernet.")

    # Priority 2: key file persisted on disk
    key_file = os.getenv("PROXY_PASSWORD_KEY_FILE", "./.secret/proxy_key.key")
    if os.path.exists(key_file):
        with open(key_file, "rb") as f:
            key = f.read().strip()
            try:
                Fernet(key)  # validate
                return key
            except Exception:
                raise RuntimeError(f"Existing key file at {key_file} is invalid for Fernet.")

    # Generate new key and persist
    if Fernet is None:
        raise RuntimeError("cryptography package is required for password encryption. Please install it and try again.")
    key = Fernet.generate_key()
    _ensure_dir(key_file)
    with open(key_file, "wb") as f:
        f.write(key)
    return key


@lru_cache(maxsize=1)
def _get_fernet() -> Fernet:
    key = _load_or_create_key()
    return Fernet(key)


def encrypt_string(plain_text: Optional[str]) -> Optional[str]:
    if plain_text is None:
        return None
    text = plain_text.strip()
    if text == "":
        return None
    token = _get_fernet().encrypt(text.encode("utf-8")).decode("utf-8")
    return f"enc${token}"


def decrypt_string_if_encrypted(value: Optional[str]) -> Optional[str]:
    if value is None:
        return None
    text = value.strip()
    if text == "":
        return None
    # Backward compatibility: if not prefixed, assume plaintext
    if not text.startswith("enc$"):
        return text
    token = text[4:]
    try:
        plain = _get_fernet().decrypt(token.encode("utf-8")).decode("utf-8")
        return plain
    except InvalidToken:
        # On failure, do not leak token; treat as absent
        return None
    except Exception:
        return None

